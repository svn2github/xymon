<?xml version="1.0" encoding="iso-8859-1" ?> 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">  
<!--http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd-->  
<html xmlns="http://www.w3.org/1999/xhtml"  
> 
<head><title>5 Behind the scenes</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)" /> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)" /> 
<!-- html4-uni,2,html,xhtml --> 
<meta name="src" content="hobbit-sysadmin-guide.tex" /> 
<meta name="date" content="2008-04-26 19:37:00" /> 
<link rel="stylesheet" type="text/css" href="hobbit-sysadmin-guide.css" /> 
</head><body 
>
   <!--l. 1--><div class="crosslinks"><p class="noindent">[<a 
href="hobbit-sysadmin-guidech6.html" >next</a>] [<a 
href="hobbit-sysadmin-guidech4.html" >prev</a>] [<a 
href="hobbit-sysadmin-guidech4.html#tailhobbit-sysadmin-guidech4.html" >prev-tail</a>] [<a 
href="#tailhobbit-sysadmin-guidech5.html">tail</a>] [<a 
href="hobbit-sysadmin-guide.html#hobbit-sysadmin-guidech5.html" >up</a>] </p></div>
   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;5</span><br /><a 
 id="x9-980005"></a>Behind the scenes</h2>
<!--l. 4--><p class="noindent">Unlike many revision control systems, the concepts upon which Mercurial is built are simple enough that it&#x2019;s easy to understand
how the software really works. Knowing this certainly isn&#x2019;t necessary, but I find it useful to have a &#x201C;mental model&#x201D; of what&#x2019;s
going on.
</p><!--l. 9--><p class="indent">   This understanding gives me confidence that Mercurial has been carefully designed to be both <span 
class="ptmri7t-">safe </span>and <span 
class="ptmri7t-">efficient</span>. And just as
importantly, if it&#x2019;s easy for me to retain a good idea of what the software is doing when I perform a revision control task, I&#x2019;m
less likely to be surprised by its behaviour.
</p><!--l. 15--><p class="indent">   In this chapter, we&#x2019;ll initially cover the core concepts behind Mercurial&#x2019;s design, then continue to discuss some of the
interesting details of its implementation.
</p>
   <h3 class="sectionHead"><span class="titlemark">5.1    </span> <a 
 id="x9-990005.1"></a>Mercurial&#x2019;s historical record</h3>
<!--l. 21--><p class="noindent">
</p>
   <h4 class="subsectionHead"><span class="titlemark">5.1.1    </span> <a 
 id="x9-1000005.1.1"></a>Tracking the history of a single file</h4>
<!--l. 23--><p class="noindent">When Mercurial tracks modifications to a file, it stores the history of that file in a metadata object called a <span 
class="ptmri7t-">filelog</span>. Each entry in
the filelog contains enough information to reconstruct one revision of the file that is being tracked. Filelogs are stored as files in
the <a 
 id="dx9-100001"></a><span 
class="pcrr7tn-">.hg/store/data </span>directory. A filelog contains two kinds of information: revision data, and an index to help Mercurial to
find a revision efficiently.
</p><!--l. 31--><p class="indent">   A file that is large, or has a lot of history, has its filelog stored in separate data (&#x201C;<span 
class="pcrr7tn-">.d</span>&#x201D; suffix) and index (&#x201C;<span 
class="pcrr7tn-">.i</span>&#x201D; suffix) files. For
small files without much history, the revision data and index are combined in a single &#x201C;<span 
class="pcrr7tn-">.i</span>&#x201D; file. The correspondence
between a file in the working directory and the filelog that tracks its history in the repository is illustrated in
figure&#x00A0;<a 
href="#x9-1000021">5.1<!--tex4ht:ref: fig:concepts:filelog --></a>.
</p>
   <hr class="figure" /><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x9-1000021"></a>
                                                                                         
                                                                                         
<!--l. 41--><p class="noindent"><img 
src="filelog.png" alt="PIC"  
 />
<br /> </p><table class="caption" 
><tr style="vertical-align:baseline;" class="caption"><td class="id">Figure&#x00A0;5.1: </td><td  
class="content">Relationships between files in working directory and filelogs in repository</td></tr></table><!--tex4ht:label?: x9-1000021 -->
                                                                                         
                                                                                         
   </td></tr></table></div><hr class="endfigure" />
   <h4 class="subsectionHead"><span class="titlemark">5.1.2    </span> <a 
 id="x9-1010005.1.2"></a>Managing tracked files</h4>
<!--l. 49--><p class="noindent">Mercurial uses a structure called a <span 
class="ptmri7t-">manifest </span>to collect together information about the files that it tracks. Each entry in the
manifest contains information about the files present in a single changeset. An entry records which files are present in the
changeset, the revision of each file, and a few other pieces of file metadata.
</p><!--l. 55--><p class="noindent">
</p>
   <h4 class="subsectionHead"><span class="titlemark">5.1.3    </span> <a 
 id="x9-1020005.1.3"></a>Recording changeset information</h4>
<!--l. 57--><p class="noindent">The <span 
class="ptmri7t-">changelog </span>contains information about each changeset. Each revision records who committed a change, the changeset
comment, other pieces of changeset-related information, and the revision of the manifest to use.
</p><!--l. 62--><p class="noindent">
</p>
   <h4 class="subsectionHead"><span class="titlemark">5.1.4    </span> <a 
 id="x9-1030005.1.4"></a>Relationships between revisions</h4>
<!--l. 64--><p class="noindent">Within a changelog, a manifest, or a filelog, each revision stores a pointer to its immediate parent (or to its two parents, if it&#x2019;s a
merge revision). As I mentioned above, there are also relationships between revisions <span 
class="ptmri7t-">across </span>these structures, and they are
hierarchical in nature.
</p><!--l. 70--><p class="indent">   For every changeset in a repository, there is exactly one revision stored in the changelog. Each revision of the
changelog contains a pointer to a single revision of the manifest. A revision of the manifest stores a pointer to a
single revision of each filelog tracked when that changeset was created. These relationships are illustrated in
figure&#x00A0;<a 
href="#x9-1030012">5.2<!--tex4ht:ref: fig:concepts:metadata --></a>.
</p>
   <hr class="figure" /><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x9-1030012"></a>
                                                                                         
                                                                                         
<!--l. 79--><p class="noindent"><img 
src="metadata.png" alt="PIC"  
 />
<br /> </p><table class="caption" 
><tr style="vertical-align:baseline;" class="caption"><td class="id">Figure&#x00A0;5.2: </td><td  
class="content">Metadata relationships</td></tr></table><!--tex4ht:label?: x9-1030012 -->
                                                                                         
                                                                                         
   </td></tr></table></div><hr class="endfigure" />
<!--l. 84--><p class="indent">   As the illustration shows, there is <span 
class="ptmri7t-">not </span>a &#x201C;one to one&#x201D; relationship between revisions in the changelog, manifest, or filelog. If
the manifest hasn&#x2019;t changed between two changesets, the changelog entries for those changesets will point to the same revision
of the manifest. If a file that Mercurial tracks hasn&#x2019;t changed between two changesets, the entry for that file in the two revisions
of the manifest will point to the same revision of its filelog.
</p>
   <h3 class="sectionHead"><span class="titlemark">5.2    </span> <a 
 id="x9-1040005.2"></a>Safe, efficient storage</h3>
<!--l. 94--><p class="noindent">The underpinnings of changelogs, manifests, and filelogs are provided by a single structure called the <span 
class="ptmri7t-">revlog</span>.
</p><!--l. 97--><p class="noindent">
</p>
   <h4 class="subsectionHead"><span class="titlemark">5.2.1    </span> <a 
 id="x9-1050005.2.1"></a>Efficient storage</h4>
<!--l. 99--><p class="noindent">The revlog provides efficient storage of revisions using a <span 
class="ptmri7t-">delta </span>mechanism. Instead of storing a complete copy of a file for each
revision, it stores the changes needed to transform an older revision into the new revision. For many kinds of file data, these
deltas are typically a fraction of a percent of the size of a full copy of a file.
</p><!--l. 106--><p class="indent">   Some obsolete revision control systems can only work with deltas of text files. They must either store binary files as
complete snapshots or encoded into a text representation, both of which are wasteful approaches. Mercurial can efficiently
handle deltas of files with arbitrary binary contents; it doesn&#x2019;t need to treat text as special.
</p><!--l. 112--><p class="noindent">
</p>
   <h4 class="subsectionHead"><span class="titlemark">5.2.2    </span> <a 
 id="x9-1060005.2.2"></a>Safe operation</h4>
<!--l. 115--><p class="noindent">Mercurial only ever <span 
class="ptmri7t-">appends </span>data to the end of a revlog file. It never modifies a section of a file after it has written it. This is
both more robust and efficient than schemes that need to modify or rewrite data.
</p><!--l. 120--><p class="indent">   In addition, Mercurial treats every write as part of a <span 
class="ptmri7t-">transaction </span>that can span a number of files. A transaction is <span 
class="ptmri7t-">atomic</span>:
either the entire transaction succeeds and its effects are all visible to readers in one go, or the whole thing is undone. This
guarantee of atomicity means that if you&#x2019;re running two copies of Mercurial, where one is reading data and one is writing it, the
reader will never see a partially written result that might confuse it.
</p><!--l. 128--><p class="indent">   The fact that Mercurial only appends to files makes it easier to provide this transactional guarantee. The easier it is to do
stuff like this, the more confident you should be that it&#x2019;s done correctly.
</p><!--l. 132--><p class="noindent">
</p>
   <h4 class="subsectionHead"><span class="titlemark">5.2.3    </span> <a 
 id="x9-1070005.2.3"></a>Fast retrieval</h4>
<!--l. 134--><p class="noindent">Mercurial cleverly avoids a pitfall common to all earlier revision control systems: the problem of <span 
class="ptmri7t-">inefficient retrieval</span>. Most
revision control systems store the contents of a revision as an incremental series of modifications against a &#x201C;snapshot&#x201D;. To
reconstruct a specific revision, you must first read the snapshot, and then every one of the revisions between the snapshot and
your target revision. The more history that a file accumulates, the more revisions you must read, hence the longer it takes to
reconstruct a particular revision.
</p>
   <hr class="figure" /><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x9-1070013"></a>
                                                                                         
                                                                                         
<!--l. 146--><p class="noindent"><img 
src="snapshot.png" alt="PIC"  
 />
<br /> </p><table class="caption" 
><tr style="vertical-align:baseline;" class="caption"><td class="id">Figure&#x00A0;5.3: </td><td  
class="content">Snapshot of a revlog, with incremental deltas</td></tr></table><!--tex4ht:label?: x9-1070013 -->
                                                                                         
                                                                                         
   </td></tr></table></div><hr class="endfigure" />
<!--l. 151--><p class="indent">   The innovation that Mercurial applies to this problem is simple but effective. Once the cumulative amount of delta
information stored since the last snapshot exceeds a fixed threshold, it stores a new snapshot (compressed, of course), instead of
another delta. This makes it possible to reconstruct <span 
class="ptmri7t-">any </span>revision of a file quickly. This approach works so well that it has since
been copied by several other revision control systems.
</p><!--l. 159--><p class="indent">   Figure&#x00A0;<a 
href="#x9-1070013">5.3<!--tex4ht:ref: fig:concepts:snapshot --></a> illustrates the idea. In an entry in a revlog&#x2019;s index file, Mercurial stores the range of entries from the data file that
it must read to reconstruct a particular revision.
</p>
   <h5 class="subsubsectionHead"><a 
 id="x9-1080005.2.3"></a>Aside: the influence of video compression</h5>
<!--l. 165--><p class="noindent">If you&#x2019;re familiar with video compression or have ever watched a TV feed through a digital cable or satellite service, you may
know that most video compression schemes store each frame of video as a delta against its predecessor frame. In addition, these
schemes use &#x201C;lossy&#x201D; compression techniques to increase the compression ratio, so visual errors accumulate over the course of a
number of inter-frame deltas.
</p><!--l. 173--><p class="indent">   Because it&#x2019;s possible for a video stream to &#x201C;drop out&#x201D; occasionally due to signal glitches, and to limit the accumulation of
artefacts introduced by the lossy compression process, video encoders periodically insert a complete frame (called a &#x201C;key
frame&#x201D;) into the video stream; the next delta is generated against that frame. This means that if the video signal gets interrupted,
it will resume once the next key frame is received. Also, the accumulation of encoding errors restarts anew with each key
frame.
</p><!--l. 182--><p class="noindent">
</p>
   <h4 class="subsectionHead"><span class="titlemark">5.2.4    </span> <a 
 id="x9-1090005.2.4"></a>Identification and strong integrity</h4>
<!--l. 184--><p class="noindent">Along with delta or snapshot information, a revlog entry contains a cryptographic hash of the data that it represents. This makes
it difficult to forge the contents of a revision, and easy to detect accidental corruption.
</p><!--l. 189--><p class="indent">   Hashes provide more than a mere check against corruption; they are used as the identifiers for revisions. The changeset
identification hashes that you see as an end user are from revisions of the changelog. Although filelogs and the manifest also
use hashes, Mercurial only uses these behind the scenes.
</p><!--l. 195--><p class="indent">   Mercurial verifies that hashes are correct when it retrieves file revisions and when it pulls changes from another repository.
If it encounters an integrity problem, it will complain and stop whatever it&#x2019;s doing.
</p><!--l. 200--><p class="indent">   In addition to the effect it has on retrieval efficiency, Mercurial&#x2019;s use of periodic snapshots makes it more robust against
partial data corruption. If a revlog becomes partly corrupted due to a hardware error or system bug, it&#x2019;s often possible to
reconstruct some or most revisions from the uncorrupted sections of the revlog, both before and after the corrupted section.
This would not be possible with a delta-only storage model.
</p><!--l. 209--><p class="noindent">
</p>
   <h3 class="sectionHead"><span class="titlemark">5.3    </span> <a 
 id="x9-1100005.3"></a>Revision history, branching, and merging</h3>
<!--l. 211--><p class="noindent">Every entry in a Mercurial revlog knows the identity of its immediate ancestor revision, usually referred to as its <span 
class="ptmri7t-">parent</span>. In fact,
a revision contains room for not one parent, but two. Mercurial uses a special hash, called the &#x201C;null ID&#x201D;, to represent the idea
&#x201C;there is no parent here&#x201D;. This hash is simply a string of zeroes.
</p><!--l. 217--><p class="indent">   In figure&#x00A0;<a 
href="#x9-1100014">5.4<!--tex4ht:ref: fig:concepts:revlog --></a>, you can see an example of the conceptual structure of a revlog. Filelogs, manifests, and changelogs all have
this same structure; they differ only in the kind of data stored in each delta or snapshot.
</p><!--l. 222--><p class="indent">   The first revision in a revlog (at the bottom of the image) has the null ID in both of its parent slots. For a &#x201C;normal&#x201D; revision,
its first parent slot contains the ID of its parent revision, and its second contains the null ID, indicating that the revision has only
one real parent. Any two revisions that have the same parent ID are branches. A revision that represents a merge between
branches has two normal revision IDs in its parent slots.
                                                                                         
                                                                                         
</p>
   <hr class="figure" /><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x9-1100014"></a>
                                                                                         
                                                                                         
<!--l. 232--><p class="noindent"><img 
src="revlog.png" alt="PIC"  
 />
<br /> </p><table class="caption" 
><tr style="vertical-align:baseline;" class="caption"><td class="id">Figure&#x00A0;5.4: </td><td  
class="content"></td></tr></table><!--tex4ht:label?: x9-1100014 -->
                                                                                         
                                                                                         
   </td></tr></table></div><hr class="endfigure" />
   <h3 class="sectionHead"><span class="titlemark">5.4    </span> <a 
 id="x9-1110005.4"></a>The working directory</h3>
<!--l. 239--><p class="noindent">In the working directory, Mercurial stores a snapshot of the files from the repository as of a particular changeset.
</p><!--l. 242--><p class="indent">   The working directory &#x201C;knows&#x201D; which changeset it contains. When you update the working directory to contain a particular
changeset, Mercurial looks up the appropriate revision of the manifest to find out which files it was tracking at the time that
changeset was committed, and which revision of each file was then current. It then recreates a copy of each of those files, with
the same contents it had when the changeset was committed.
</p><!--l. 250--><p class="indent">   The <span 
class="ptmri7t-">dirstate </span>contains Mercurial&#x2019;s knowledge of the working directory. This details which changeset the working directory
is updated to, and all of the files that Mercurial is tracking in the working directory.
</p><!--l. 255--><p class="indent">   Just as a revision of a revlog has room for two parents, so that it can represent either a normal revision (with one
parent) or a merge of two earlier revisions, the dirstate has slots for two parents. When you use the <a 
 id="dx9-111001"></a>&#x201C;<span 
class="pcrr7tn-">hg update</span>&#x201D;
command, the changeset that you update to is stored in the &#x201C;first parent&#x201D; slot, and the null ID in the second. When
you <a 
 id="dx9-111002"></a>&#x201C;<span 
class="pcrr7tn-">hg merge</span>&#x201D; with another changeset, the first parent remains unchanged, and the second parent is filled in
with the changeset you&#x2019;re merging with. The <a 
 id="dx9-111003"></a>&#x201C;<span 
class="pcrr7tn-">hg parents</span>&#x201D; command tells you what the parents of the dirstate
are.
</p><!--l. 265--><p class="noindent">
</p>
   <h4 class="subsectionHead"><span class="titlemark">5.4.1    </span> <a 
 id="x9-1120005.4.1"></a>What happens when you commit</h4>
<!--l. 267--><p class="noindent">The dirstate stores parent information for more than just book-keeping purposes. Mercurial uses the parents of the dirstate as
<span 
class="ptmri7t-">the parents of a new changeset </span>when you perform a commit.
</p>
   <hr class="figure" /><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x9-1120015"></a>
                                                                                         
                                                                                         
<!--l. 273--><p class="noindent"><img 
src="wdir.png" alt="PIC"  
 />
<br /> </p><table class="caption" 
><tr style="vertical-align:baseline;" class="caption"><td class="id">Figure&#x00A0;5.5: </td><td  
class="content">The working directory can have two parents</td></tr></table><!--tex4ht:label?: x9-1120015 -->
                                                                                         
                                                                                         
   </td></tr></table></div><hr class="endfigure" />
<!--l. 278--><p class="indent">   Figure&#x00A0;<a 
href="#x9-1120015">5.5<!--tex4ht:ref: fig:concepts:wdir --></a> shows the normal state of the working directory, where it has a single changeset as parent. That changeset is the
<span 
class="ptmri7t-">tip</span>, the newest changeset in the repository that has no children.
</p>
   <hr class="figure" /><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x9-1120026"></a>
                                                                                         
                                                                                         
<!--l. 285--><p class="noindent"><img 
src="wdir-after-commit.png" alt="PIC"  
 />
<br /> </p><table class="caption" 
><tr style="vertical-align:baseline;" class="caption"><td class="id">Figure&#x00A0;5.6: </td><td  
class="content">The working directory gains new parents after a commit</td></tr></table><!--tex4ht:label?: x9-1120026 -->
                                                                                         
                                                                                         
   </td></tr></table></div><hr class="endfigure" />
<!--l. 290--><p class="indent">   It&#x2019;s useful to think of the working directory as &#x201C;the changeset I&#x2019;m about to commit&#x201D;. Any files that you tell Mercurial that
you&#x2019;ve added, removed, renamed, or copied will be reflected in that changeset, as will modifications to any
files that Mercurial is already tracking; the new changeset will have the parents of the working directory as its
parents.
</p><!--l. 297--><p class="indent">   After a commit, Mercurial will update the parents of the working directory, so that the first parent is the ID of the new
changeset, and the second is the null ID. This is shown in figure&#x00A0;<a 
href="#x9-1120026">5.6<!--tex4ht:ref: fig:concepts:wdir-after-commit --></a>. Mercurial doesn&#x2019;t touch any of the files in the working
directory when you commit; it just modifies the dirstate to note its new parents.
</p>
   <h4 class="subsectionHead"><span class="titlemark">5.4.2    </span> <a 
 id="x9-1130005.4.2"></a>Creating a new head</h4>
<!--l. 306--><p class="noindent">It&#x2019;s perfectly normal to update the working directory to a changeset other than the current tip. For example, you might want to
know what your project looked like last Tuesday, or you could be looking through changesets to see which one introduced a
bug. In cases like this, the natural thing to do is update the working directory to the changeset you&#x2019;re interested in, and then
examine the files in the working directory directly to see their contents as they werea when you committed that changeset. The
effect of this is shown in figure&#x00A0;<a 
href="#x9-1130017">5.7<!--tex4ht:ref: fig:concepts:wdir-pre-branch --></a>.
</p>
   <hr class="figure" /><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x9-1130017"></a>
                                                                                         
                                                                                         
<!--l. 318--><p class="noindent"><img 
src="wdir-pre-branch.png" alt="PIC"  
 />
<br /> </p><table class="caption" 
><tr style="vertical-align:baseline;" class="caption"><td class="id">Figure&#x00A0;5.7: </td><td  
class="content">The working directory, updated to an older changeset</td></tr></table><!--tex4ht:label?: x9-1130017 -->
                                                                                         
                                                                                         
   </td></tr></table></div><hr class="endfigure" />
<!--l. 323--><p class="indent">   Having updated the working directory to an older changeset, what happens if you make some changes, and then commit?
Mercurial behaves in the same way as I outlined above. The parents of the working directory become the parents of
the new changeset. This new changeset has no children, so it becomes the new tip. And the repository now
contains two changesets that have no children; we call these <span 
class="ptmri7t-">heads</span>. You can see the structure that this creates in
figure&#x00A0;<a 
href="#x9-1130028">5.8<!--tex4ht:ref: fig:concepts:wdir-branch --></a>.
</p>
   <hr class="figure" /><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x9-1130028"></a>
                                                                                         
                                                                                         
<!--l. 334--><p class="noindent"><img 
src="wdir-branch.png" alt="PIC"  
 />
<br /> </p><table class="caption" 
><tr style="vertical-align:baseline;" class="caption"><td class="id">Figure&#x00A0;5.8: </td><td  
class="content">After a commit made while synced to an older changeset</td></tr></table><!--tex4ht:label?: x9-1130028 -->
                                                                                         
                                                                                         
   </td></tr></table></div><hr class="endfigure" />
</p>
   <div class="fbox"><span 
class="ptmb7t-">Note:   </span>If you&#x2019;re new to Mercurial, you should keep in mind a common &#x201C;error&#x201D;,
which  is  to  use  the  &#x201C;<span 
class="pcrr7tn-">hg pull</span>&#x201D;  command  without  any  options.  By  default,  the
&#x201C;<span 
class="pcrr7tn-">hg pull</span>&#x201D; command <span 
class="ptmri7t-">does not </span>update the working directory, so you&#x2019;ll bring new
changesets  into  your  repository,  but  the  working  directory  will  stay  synced  at
the  same  changeset  as  before  the  pull.  If  you  make  some  changes  and  commit
afterwards, you&#x2019;ll thus create a new head, because your working directory isn&#x2019;t
synced to whatever the current tip is.
I  put  the  word  &#x201C;error&#x201D;  in  quotes  because  all  that  you  need  to  do  to  rectify  this
situation is &#x201C;<span 
class="pcrr7tn-">hg merge</span>&#x201D;, then &#x201C;<span 
class="pcrr7tn-">hg commit</span>&#x201D;. In other words, this almost never has
negative consequences; it just surprises people. I&#x2019;ll discuss other ways to avoid this
behaviour, and why Mercurial behaves in this initially surprising way, later on.      </div>
   <h4 class="subsectionHead"><span class="titlemark">5.4.3    </span> <a 
 id="x9-1140005.4.3"></a>Merging heads</h4>
<!--l. 359--><p class="noindent">When you run the <a 
 id="dx9-114001"></a>&#x201C;<span 
class="pcrr7tn-">hg merge</span>&#x201D; command, Mercurial leaves the first parent of the working directory unchanged, and sets the
second parent to the changeset you&#x2019;re merging with, as shown in figure&#x00A0;<a 
href="#x9-1140029">5.9<!--tex4ht:ref: fig:concepts:wdir-merge --></a>.
</p>
   <hr class="figure" /><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x9-1140029"></a>
                                                                                         
                                                                                         
<!--l. 366--><p class="noindent"><img 
src="wdir-merge.png" alt="PIC"  
 />
<br /> </p><table class="caption" 
><tr style="vertical-align:baseline;" class="caption"><td class="id">Figure&#x00A0;5.9: </td><td  
class="content">Merging two heads</td></tr></table><!--tex4ht:label?: x9-1140029 -->
                                                                                         
                                                                                         
   </td></tr></table></div><hr class="endfigure" />
<!--l. 371--><p class="indent">   Mercurial also has to modify the working directory, to merge the files managed in the two changesets. Simplified a little, the
merging process goes like this, for every file in the manifests of both changesets. </p>
     <ul><li><span class="dt">
     </span><span class="dd">If neither changeset has modified a file, do nothing with that file.
     </span><li><span class="dt">
     </span><span class="dd">If one changeset has modified a file, and the other hasn&#x2019;t, create the modified copy of the file in the working
     directory.
     </span><li><span class="dt">
     </span><span class="dd">If one changeset has removed a file, and the other hasn&#x2019;t (or has also deleted it), delete the file from the working
     directory.
     </span><li><span class="dt">
     </span><span class="dd">If one changeset has removed a file, but the other has modified the file, ask the user what to do: keep the modified
     file, or remove it?
     </span><li><span class="dt">
     </span><span class="dd">If both changesets have modified a file, invoke an external merge program to choose the new contents for the
     merged file. This may require input from the user.
     </span><li><span class="dt">
     </span><span class="dd">If one changeset has modified a file, and the other has renamed or copied the file, make sure that the changes
     follow the new name of the file.</li></ul>
<!--l. 392--><p class="noindent">There are more details&#x2014;merging has plenty of corner cases&#x2014;but these are the most common choices that are involved in a merge.
As you can see, most cases are completely automatic, and indeed most merges finish automatically, without requiring your
input to resolve any conflicts.
</p><!--l. 398--><p class="indent">   When you&#x2019;re thinking about what happens when you commit after a merge, once again the working directory is &#x201C;the
changeset I&#x2019;m about to commit&#x201D;. After the <a 
 id="dx9-114003"></a>&#x201C;<span 
class="pcrr7tn-">hg merge</span>&#x201D; command completes, the working directory has two parents; these will
become the parents of the new changeset.
</p><!--l. 404--><p class="indent">   Mercurial lets you perform multiple merges, but you must commit the results of each individual merge as you go. This is
necessary because Mercurial only tracks two parents for both revisions and the working directory. While it would be technically
possible to merge multiple changesets at once, the prospect of user confusion and making a terrible mess of a merge
immediately becomes overwhelming.
</p>
   <h3 class="sectionHead"><span class="titlemark">5.5    </span> <a 
 id="x9-1150005.5"></a>Other interesting design features</h3>
<!--l. 413--><p class="noindent">In the sections above, I&#x2019;ve tried to highlight some of the most important aspects of Mercurial&#x2019;s design, to illustrate that it pays
careful attention to reliability and performance. However, the attention to detail doesn&#x2019;t stop there. There are a number of other
aspects of Mercurial&#x2019;s construction that I personally find interesting. I&#x2019;ll detail a few of them here, separate from the &#x201C;big
ticket&#x201D; items above, so that if you&#x2019;re interested, you can gain a better idea of the amount of thinking that goes into a
well-designed system.
</p><!--l. 423--><p class="noindent">
</p>
   <h4 class="subsectionHead"><span class="titlemark">5.5.1    </span> <a 
 id="x9-1160005.5.1"></a>Clever compression</h4>
<!--l. 425--><p class="noindent">When appropriate, Mercurial will store both snapshots and deltas in compressed form. It does this by always <span 
class="ptmri7t-">trying to</span>
compress a snapshot or delta, but only storing the compressed version if it&#x2019;s smaller than the uncompressed
version.
                                                                                         
                                                                                         
</p><!--l. 430--><p class="indent">   This means that Mercurial does &#x201C;the right thing&#x201D; when storing a file whose native form is compressed, such as a <span 
class="pcrr7tn-">zip </span>archive
or a JPEG image. When these types of files are compressed a second time, the resulting file is usually bigger than the
once-compressed form, and so Mercurial will store the plain <span 
class="pcrr7tn-">zip </span>or JPEG.
</p><!--l. 436--><p class="indent">   Deltas between revisions of a compressed file are usually larger than snapshots of the file, and Mercurial again
does &#x201C;the right thing&#x201D; in these cases. It finds that such a delta exceeds the threshold at which it should store
a complete snapshot of the file, so it stores the snapshot, again saving space compared to a naive delta-only
approach.
</p><!--l. 443--><p class="noindent">
</p>
   <h5 class="subsubsectionHead"><a 
 id="x9-1170005.5.1"></a>Network recompression</h5>
<!--l. 445--><p class="noindent">When storing revisions on disk, Mercurial uses the &#x201C;deflate&#x201D; compression algorithm (the same one used by
the popular <span 
class="pcrr7tn-">zip </span>archive format), which balances good speed with a respectable compression ratio. However,
when transmitting revision data over a network connection, Mercurial uncompresses the compressed revision
data.
</p><!--l. 452--><p class="indent">   If the connection is over HTTP, Mercurial recompresses the entire stream of data using a compression algorithm that gives a
better compression ratio (the Burrows-Wheeler algorithm from the widely used <span 
class="pcrr7tn-">bzip2 </span>compression package). This
combination of algorithm and compression of the entire stream (instead of a revision at a time) substantially
reduces the number of bytes to be transferred, yielding better network performance over almost all kinds of
network.
</p><!--l. 460--><p class="indent">   (If the connection is over <a 
 id="dx9-117001"></a><span 
class="pcrr7tn-">ssh</span>, Mercurial <span 
class="ptmri7t-">doesn&#x2019;t </span>recompress the stream, because <a 
 id="dx9-117002"></a><span 
class="pcrr7tn-">ssh </span>can already do this
itself.)
</p><!--l. 464--><p class="noindent">
</p>
   <h4 class="subsectionHead"><span class="titlemark">5.5.2    </span> <a 
 id="x9-1180005.5.2"></a>Read/write ordering and atomicity</h4>
<!--l. 466--><p class="noindent">Appending to files isn&#x2019;t the whole story when it comes to guaranteeing that a reader won&#x2019;t see a partial write. If you recall
figure&#x00A0;<a 
href="#x9-1030012">5.2<!--tex4ht:ref: fig:concepts:metadata --></a>, revisions in the changelog point to revisions in the manifest, and revisions in the manifest point to revisions in
filelogs. This hierarchy is deliberate.
</p><!--l. 472--><p class="indent">   A writer starts a transaction by writing filelog and manifest data, and doesn&#x2019;t write any changelog data until those are
finished. A reader starts by reading changelog data, then manifest data, followed by filelog data.
</p><!--l. 477--><p class="indent">   Since the writer has always finished writing filelog and manifest data before it writes to the changelog, a reader will never
read a pointer to a partially written manifest revision from the changelog, and it will never read a pointer to a partially written
filelog revision from the manifest.
</p><!--l. 483--><p class="noindent">
</p>
   <h4 class="subsectionHead"><span class="titlemark">5.5.3    </span> <a 
 id="x9-1190005.5.3"></a>Concurrent access</h4>
<!--l. 485--><p class="noindent">The read/write ordering and atomicity guarantees mean that Mercurial never needs to <span 
class="ptmri7t-">lock </span>a repository when it&#x2019;s reading data,
even if the repository is being written to while the read is occurring. This has a big effect on scalability; you can have an
arbitrary number of Mercurial processes safely reading data from a repository safely all at once, no matter whether it&#x2019;s being
written to or not.
</p><!--l. 492--><p class="indent">   The lockless nature of reading means that if you&#x2019;re sharing a repository on a multi-user system, you don&#x2019;t need to grant
other local users permission to <span 
class="ptmri7t-">write </span>to your repository in order for them to be able to clone it or pull changes from it; they only
need <span 
class="ptmri7t-">read </span>permission. (This is <span 
class="ptmri7t-">not </span>a common feature among revision control systems, so don&#x2019;t take it for granted!
Most require readers to be able to lock a repository to access it safely, and this requires write permission on
at least one directory, which of course makes for all kinds of nasty and annoying security and administrative
problems.)
                                                                                         
                                                                                         
</p><!--l. 503--><p class="indent">   Mercurial uses locks to ensure that only one process can write to a repository at a time (the locking mechanism is safe even
over filesystems that are notoriously hostile to locking, such as NFS). If a repository is locked, a writer will wait for a
while to retry if the repository becomes unlocked, but if the repository remains locked for too long, the process
attempting to write will time out after a while. This means that your daily automated scripts won&#x2019;t get stuck
forever and pile up if a system crashes unnoticed, for example. (Yes, the timeout is configurable, from zero to
infinity.)
</p><!--l. 513--><p class="noindent">
</p>
   <h5 class="subsubsectionHead"><a 
 id="x9-1200005.5.3"></a>Safe dirstate access</h5>
<!--l. 515--><p class="noindent">As with revision data, Mercurial doesn&#x2019;t take a lock to read the dirstate file; it does acquire a lock to write it. To avoid the
possibility of reading a partially written copy of the dirstate file, Mercurial writes to a file with a unique name in the same
directory as the dirstate file, then renames the temporary file atomically to <span 
class="pcrr7tn-">dirstate</span>. The file named <span 
class="pcrr7tn-">dirstate </span>is thus
guaranteed to be complete, not partially written.
</p><!--l. 523--><p class="noindent">
</p>
   <h4 class="subsectionHead"><span class="titlemark">5.5.4    </span> <a 
 id="x9-1210005.5.4"></a>Avoiding seeks</h4>
<!--l. 525--><p class="noindent">Critical to Mercurial&#x2019;s performance is the avoidance of seeks of the disk head, since any seek is far more expensive than even a
comparatively large read operation.
</p><!--l. 529--><p class="indent">   This is why, for example, the dirstate is stored in a single file. If there were a dirstate file per directory that Mercurial
tracked, the disk would seek once per directory. Instead, Mercurial reads the entire single dirstate file in one
step.
</p><!--l. 534--><p class="indent">   Mercurial also uses a &#x201C;copy on write&#x201D; scheme when cloning a repository on local storage. Instead of copying every revlog
file from the old repository into the new repository, it makes a &#x201C;hard link&#x201D;, which is a shorthand way to say &#x201C;these two names
point to the same file&#x201D;. When Mercurial is about to write to one of a revlog&#x2019;s files, it checks to see if the number of names
pointing at the file is greater than one. If it is, more than one repository is using the file, so Mercurial makes a new copy of the
file that is private to this repository.
</p><!--l. 544--><p class="indent">   A few revision control developers have pointed out that this idea of making a complete private copy of a file is not very
efficient in its use of storage. While this is true, storage is cheap, and this method gives the highest performance while
deferring most book-keeping to the operating system. An alternative scheme would most likely reduce performance
and increase the complexity of the software, each of which is much more important to the &#x201C;feel&#x201D; of day-to-day
use.
</p><!--l. 552--><p class="noindent">
</p>
   <h4 class="subsectionHead"><span class="titlemark">5.5.5    </span> <a 
 id="x9-1220005.5.5"></a>Other contents of the dirstate</h4>
<!--l. 554--><p class="noindent">Because Mercurial doesn&#x2019;t force you to tell it when you&#x2019;re modifying a file, it uses the dirstate to store some extra information
so it can determine efficiently whether you have modified a file. For each file in the working directory, it stores the time that it
last modified the file itself, and the size of the file at that time.
</p><!--l. 560--><p class="indent">   When you explicitly <a 
 id="dx9-122001"></a>&#x201C;<span 
class="pcrr7tn-">hg add</span>&#x201D;, <a 
 id="dx9-122002"></a>&#x201C;<span 
class="pcrr7tn-">hg remove</span>&#x201D;, <a 
 id="dx9-122003"></a>&#x201C;<span 
class="pcrr7tn-">hg rename</span>&#x201D; or <a 
 id="dx9-122004"></a>&#x201C;<span 
class="pcrr7tn-">hg copy</span>&#x201D; files, Mercurial updates the dirstate so that it
knows what to do with those files when you commit.
</p><!--l. 564--><p class="indent">   When Mercurial is checking the states of files in the working directory, it first checks a file&#x2019;s modification time. If that has
not changed, the file must not have been modified. If the file&#x2019;s size has changed, the file must have been modified. If the
modification time has changed, but the size has not, only then does Mercurial need to read the actual contents of the file to
see if they&#x2019;ve changed. Storing these few extra pieces of information dramatically reduces the amount of data
that Mercurial needs to read, which yields large performance improvements compared to other revision control
systems.
                                                                                         
                                                                                         
                                                                                         
                                                                                         
                                                                                         
                                                                                         
                                                                                         
                                                                                         
</p>
   <!--l. 1--><div class="crosslinks"><p class="noindent">[<a 
href="hobbit-sysadmin-guidech6.html" >next</a>] [<a 
href="hobbit-sysadmin-guidech4.html" >prev</a>] [<a 
href="hobbit-sysadmin-guidech4.html#tailhobbit-sysadmin-guidech4.html" >prev-tail</a>] [<a 
href="hobbit-sysadmin-guidech5.html" >front</a>] [<a 
href="hobbit-sysadmin-guide.html#hobbit-sysadmin-guidech5.html" >up</a>] </p></div>
<!--l. 1--><p class="indent">   <a 
 id="tailhobbit-sysadmin-guidech5.html"></a>   </p> 
</body></html> 
